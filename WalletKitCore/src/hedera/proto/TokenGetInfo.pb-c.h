/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: TokenGetInfo.proto */

#ifndef PROTOBUF_C_TokenGetInfo_2eproto__INCLUDED
#define PROTOBUF_C_TokenGetInfo_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "BasicTypes.pb-c.h"
#include "CustomFees.pb-c.h"
#include "QueryHeader.pb-c.h"
#include "ResponseHeader.pb-c.h"
#include "Timestamp.pb-c.h"
#include "Duration.pb-c.h"

typedef struct Proto__TokenGetInfoQuery Proto__TokenGetInfoQuery;
typedef struct Proto__TokenInfo Proto__TokenInfo;
typedef struct Proto__TokenGetInfoResponse Proto__TokenGetInfoResponse;


/* --- enums --- */


/* --- messages --- */

/*
 * Gets information about Token instance 
 */
struct  Proto__TokenGetInfoQuery
{
  ProtobufCMessage base;
  /*
   * Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither)
   */
  Proto__QueryHeader *header;
  /*
   * The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID response is returned.
   */
  Proto__TokenID *token;
};
#define PROTO__TOKEN_GET_INFO_QUERY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_get_info_query__descriptor) \
    , NULL, NULL }


/*
 * The metadata about a Token instance 
 */
struct  Proto__TokenInfo
{
  ProtobufCMessage base;
  /*
   * ID of the token instance
   */
  Proto__TokenID *tokenid;
  /*
   * The name of the token. It is a string of ASCII only characters
   */
  char *name;
  /*
   * The symbol of the token. It is a UTF-8 capitalized alphabetical string
   */
  char *symbol;
  /*
   * The number of decimal places a token is divisible by. Always 0 for tokens of type NON_FUNGIBLE_UNIQUE
   */
  uint32_t decimals;
  /*
   * For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this token instance
   */
  uint64_t totalsupply;
  /*
   * The ID of the account which is set as Treasury
   */
  Proto__AccountID *treasury;
  /*
   * The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)
   */
  Proto__Key *adminkey;
  /*
   * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.
   */
  Proto__Key *kyckey;
  /*
   * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
   */
  Proto__Key *freezekey;
  /*
   * The key which can wipe token balance of an account. If empty, wipe is not possible
   */
  Proto__Key *wipekey;
  /*
   * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
   */
  Proto__Key *supplykey;
  /*
   * The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
   */
  Proto__TokenFreezeStatus defaultfreezestatus;
  /*
   * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
   */
  Proto__TokenKycStatus defaultkycstatus;
  /*
   * Specifies whether the token was deleted or not
   */
  protobuf_c_boolean deleted;
  /*
   * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
   */
  Proto__AccountID *autorenewaccount;
  /*
   * The interval at which the auto-renew account will be charged to extend the token's expiry
   */
  Proto__Duration *autorenewperiod;
  /*
   * The epoch second at which the token will expire
   */
  Proto__Timestamp *expiry;
  /*
   * The memo associated with the token
   */
  char *memo;
  /*
   * The token type
   */
  Proto__TokenType tokentype;
  /*
   * The token supply type
   */
  Proto__TokenSupplyType supplytype;
  /*
   * For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial numbers) that can be in circulation
   */
  int64_t maxsupply;
  /*
   * The key which can change the custom fee schedule of the token; if not set, the fee schedule is immutable
   */
  Proto__Key *fee_schedule_key;
  /*
   * The custom fees to be assessed during a CryptoTransfer that transfers units of this token
   */
  size_t n_custom_fees;
  Proto__CustomFee **custom_fees;
};
#define PROTO__TOKEN_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_info__descriptor) \
    , NULL, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, PROTO__TOKEN_FREEZE_STATUS__FreezeNotApplicable, PROTO__TOKEN_KYC_STATUS__KycNotApplicable, 0, NULL, NULL, NULL, (char *)protobuf_c_empty_string, PROTO__TOKEN_TYPE__FUNGIBLE_COMMON, PROTO__TOKEN_SUPPLY_TYPE__INFINITE, 0, NULL, 0,NULL }


/*
 * Response when the client sends the node TokenGetInfoQuery 
 */
struct  Proto__TokenGetInfoResponse
{
  ProtobufCMessage base;
  /*
   * Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
   */
  Proto__ResponseHeader *header;
  /*
   * The information requested about this token instance
   */
  Proto__TokenInfo *tokeninfo;
};
#define PROTO__TOKEN_GET_INFO_RESPONSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_get_info_response__descriptor) \
    , NULL, NULL }


/* Proto__TokenGetInfoQuery methods */
void   proto__token_get_info_query__init
                     (Proto__TokenGetInfoQuery         *message);
size_t proto__token_get_info_query__get_packed_size
                     (const Proto__TokenGetInfoQuery   *message);
size_t proto__token_get_info_query__pack
                     (const Proto__TokenGetInfoQuery   *message,
                      uint8_t             *out);
size_t proto__token_get_info_query__pack_to_buffer
                     (const Proto__TokenGetInfoQuery   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenGetInfoQuery *
       proto__token_get_info_query__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_get_info_query__free_unpacked
                     (Proto__TokenGetInfoQuery *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenInfo methods */
void   proto__token_info__init
                     (Proto__TokenInfo         *message);
size_t proto__token_info__get_packed_size
                     (const Proto__TokenInfo   *message);
size_t proto__token_info__pack
                     (const Proto__TokenInfo   *message,
                      uint8_t             *out);
size_t proto__token_info__pack_to_buffer
                     (const Proto__TokenInfo   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenInfo *
       proto__token_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_info__free_unpacked
                     (Proto__TokenInfo *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenGetInfoResponse methods */
void   proto__token_get_info_response__init
                     (Proto__TokenGetInfoResponse         *message);
size_t proto__token_get_info_response__get_packed_size
                     (const Proto__TokenGetInfoResponse   *message);
size_t proto__token_get_info_response__pack
                     (const Proto__TokenGetInfoResponse   *message,
                      uint8_t             *out);
size_t proto__token_get_info_response__pack_to_buffer
                     (const Proto__TokenGetInfoResponse   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenGetInfoResponse *
       proto__token_get_info_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_get_info_response__free_unpacked
                     (Proto__TokenGetInfoResponse *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__TokenGetInfoQuery_Closure)
                 (const Proto__TokenGetInfoQuery *message,
                  void *closure_data);
typedef void (*Proto__TokenInfo_Closure)
                 (const Proto__TokenInfo *message,
                  void *closure_data);
typedef void (*Proto__TokenGetInfoResponse_Closure)
                 (const Proto__TokenGetInfoResponse *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor proto__token_get_info_query__descriptor;
extern const ProtobufCMessageDescriptor proto__token_info__descriptor;
extern const ProtobufCMessageDescriptor proto__token_get_info_response__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_TokenGetInfo_2eproto__INCLUDED */
