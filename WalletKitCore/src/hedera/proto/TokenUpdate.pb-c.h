/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: TokenUpdate.proto */

#ifndef PROTOBUF_C_TokenUpdate_2eproto__INCLUDED
#define PROTOBUF_C_TokenUpdate_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "BasicTypes.pb-c.h"
#include "Duration.pb-c.h"
#include "Timestamp.pb-c.h"
#include "wrappers.pb-c.h"

typedef struct Proto__TokenUpdateTransactionBody Proto__TokenUpdateTransactionBody;


/* --- enums --- */


/* --- messages --- */

/*
 * At consensus, updates an already created token to the given values.
 *If no value is given for a field, that field is left unchanged. For an immutable tokens (that is, a token without an admin key), only the expiry may be updated. Setting any other field in that case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
 *--- Signing Requirements ---
 *1. Whether or not a token has an admin key, its expiry can be extended with only the transaction payer's signature.
 *2. Updating any other field of a mutable token requires the admin key's signature.
 *3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the token to become immutable. (Other <tt>Key</tt> structures without a constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
 *4. If a new treasury is set, the new treasury account's key must sign the transaction.
 *--- Nft Requirements ---
 *1. If a non fungible token has a positive treasury balance, the operation will abort with CURRENT_TREASURY_STILL_OWNS_NFTS.
 */
struct  Proto__TokenUpdateTransactionBody
{
  ProtobufCMessage base;
  /*
   * The Token to be updated
   */
  Proto__TokenID *token;
  /*
   * The new publicly visible Token symbol, limited to a UTF-8 encoding of length <tt>tokens.maxTokenNameUtf8Bytes</tt>.
   */
  char *symbol;
  /*
   * The new publicly visible name of the Token, limited to a UTF-8 encoding of length <tt>tokens.maxSymbolUtf8Bytes</tt>.
   */
  char *name;
  /*
   * The new Treasury account of the Token. If the provided treasury account is not existing or deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token balance held in the previous Treasury Account is transferred to the new one.
   */
  Proto__AccountID *treasury;
  /*
   * The new admin key of the Token. If Token is immutable, transaction will resolve to TOKEN_IS_IMMUTABlE.
   */
  Proto__Key *adminkey;
  /*
   * The new KYC key of the Token. If Token does not have currently a KYC key, transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
   */
  Proto__Key *kyckey;
  /*
   * The new Freeze key of the Token. If the Token does not have currently a Freeze key, transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
   */
  Proto__Key *freezekey;
  /*
   * The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction will resolve to TOKEN_HAS_NO_WIPE_KEY.
   */
  Proto__Key *wipekey;
  /*
   * The new Supply key of the Token. If the Token does not have currently a Supply key, transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
   */
  Proto__Key *supplykey;
  /*
   * The new account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval.
   */
  Proto__AccountID *autorenewaccount;
  /*
   * The new interval at which the auto-renew account will be charged to extend the token's expiry.
   */
  Proto__Duration *autorenewperiod;
  /*
   * The new expiry time of the token. Expiry can be updated even if admin key is not set. If the provided expiry is earlier than the current token expiry, transaction wil resolve to INVALID_EXPIRATION_TIME
   */
  Proto__Timestamp *expiry;
  /*
   * If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)
   */
  Google__Protobuf__StringValue *memo;
  /*
   * If set, the new key to use to update the token's custom fee schedule; if the token does not currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
   */
  Proto__Key *fee_schedule_key;
};
#define PROTO__TOKEN_UPDATE_TRANSACTION_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_update_transaction_body__descriptor) \
    , NULL, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }


/* Proto__TokenUpdateTransactionBody methods */
void   proto__token_update_transaction_body__init
                     (Proto__TokenUpdateTransactionBody         *message);
size_t proto__token_update_transaction_body__get_packed_size
                     (const Proto__TokenUpdateTransactionBody   *message);
size_t proto__token_update_transaction_body__pack
                     (const Proto__TokenUpdateTransactionBody   *message,
                      uint8_t             *out);
size_t proto__token_update_transaction_body__pack_to_buffer
                     (const Proto__TokenUpdateTransactionBody   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenUpdateTransactionBody *
       proto__token_update_transaction_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_update_transaction_body__free_unpacked
                     (Proto__TokenUpdateTransactionBody *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__TokenUpdateTransactionBody_Closure)
                 (const Proto__TokenUpdateTransactionBody *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor proto__token_update_transaction_body__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_TokenUpdate_2eproto__INCLUDED */
