/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: TokenCreate.proto */

#ifndef PROTOBUF_C_TokenCreate_2eproto__INCLUDED
#define PROTOBUF_C_TokenCreate_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "Duration.pb-c.h"
#include "BasicTypes.pb-c.h"
#include "CustomFees.pb-c.h"
#include "Timestamp.pb-c.h"

typedef struct Proto__TokenCreateTransactionBody Proto__TokenCreateTransactionBody;


/* --- enums --- */


/* --- messages --- */

/*
 *Create a new token. After the token is created, the Token ID for it is in the receipt.
 *The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens from the Token Mint operation once executed. The balance of the treasury account is decreased when the Token Burn operation is executed.
 *The <tt>initialSupply</tt> is the initial supply of the smallest parts of a token (like a tinybar, not an hbar). These are the smallest units of the token which may be transferred.
 *The supply can change over time. If the total supply at some moment is <i>S</i> parts of tokens, and the token is using <i>D</i> decimals, then <i>S</i> must be less than or equal to 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will be <i>S / 10<sup>D</sup></i>.
 *If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8 decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with milli-satoshis (21 million whole tokens with 11 decimals).
 *Note that a created token is <i>immutable</i> if the <tt>adminKey</tt> is omitted. No property of an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to extend the expiry time of an immutable token.
 *A token can be either <i>FUNGIBLE_COMMON</i> or <i>NON_FUNGIBLE_UNIQUE</i>, based on its <i>TokenType</i>. If it has been omitted, <i>FUNGIBLE_COMMON</i> type is used.
 *A token can have either <i>INFINITE</i> or <i>FINITE</i> supply type, based on its <i>TokenType</i>. If it has been omitted, <i>INFINITE</i> type is used.
 *If a <i>FUNGIBLE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to a non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
 *If a <i>NON_FUNGIBLE_UNIQUE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
 *If an <i>INFINITE</i> TokenSupplyType is used, <i>maxSupply</i> should explicitly be set to 0. If it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
 *If a <i>FINITE</i> TokenSupplyType is used, <i>maxSupply</i> should be explicitly set to a non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
 */
struct  Proto__TokenCreateTransactionBody
{
  ProtobufCMessage base;
  /*
   * The publicly visible name of the token, limited to a UTF-8 encoding of length <tt>tokens.maxSymbolUtf8Bytes</tt>.
   */
  char *name;
  /*
   * The publicly visible token symbol, limited to a UTF-8 encoding of length <tt>tokens.maxTokenNameUtf8Bytes</tt>.
   */
  char *symbol;
  /*
   * For tokens of type FUNGIBLE_COMMON - the number of decimal places a token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value must be 0
   */
  uint32_t decimals;
  /*
   * Specifies the initial supply of tokens to be put in circulation. The initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type the value must be 0
   */
  uint64_t initialsupply;
  /*
   * The account which will act as a treasury for the token. This account will receive the specified initial supply or the newly minted NFTs in the case for NON_FUNGIBLE_UNIQUE Type
   */
  Proto__AccountID *treasury;
  /*
   * The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)
   */
  Proto__Key *adminkey;
  /*
   * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.
   */
  Proto__Key *kyckey;
  /*
   * The key which can sign to freeze or unfreeze an account for token transactions. If empty, freezing is not possible
   */
  Proto__Key *freezekey;
  /*
   * The key which can wipe the token balance of an account. If empty, wipe is not possible
   */
  Proto__Key *wipekey;
  /*
   * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
   */
  Proto__Key *supplykey;
  /*
   * The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If true, an account must be unfrozen before it can receive the token
   */
  protobuf_c_boolean freezedefault;
  /*
   * The epoch second at which the token should expire; if an auto-renew account and period are specified, this is coerced to the current epoch second plus the autoRenewPeriod
   */
  Proto__Timestamp *expiry;
  /*
   * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
   */
  Proto__AccountID *autorenewaccount;
  /*
   * The interval at which the auto-renew account will be charged to extend the token's expiry
   */
  Proto__Duration *autorenewperiod;
  /*
   * The memo associated with the token (UTF-8 encoding max 100 bytes)
   */
  char *memo;
  /*
   * IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON
   */
  Proto__TokenType tokentype;
  /*
   * IWA compatibility. Specified the token supply type. Defaults to INFINITE
   */
  Proto__TokenSupplyType supplytype;
  /*
   * IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!
   */
  int64_t maxsupply;
  /*
   * The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate transaction
   */
  Proto__Key *fee_schedule_key;
  /*
   * The custom fees to be assessed during a CryptoTransfer that transfers units of this token
   */
  size_t n_custom_fees;
  Proto__CustomFee **custom_fees;
};
#define PROTO__TOKEN_CREATE_TRANSACTION_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_create_transaction_body__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, (char *)protobuf_c_empty_string, PROTO__TOKEN_TYPE__FUNGIBLE_COMMON, PROTO__TOKEN_SUPPLY_TYPE__INFINITE, 0, NULL, 0,NULL }


/* Proto__TokenCreateTransactionBody methods */
void   proto__token_create_transaction_body__init
                     (Proto__TokenCreateTransactionBody         *message);
size_t proto__token_create_transaction_body__get_packed_size
                     (const Proto__TokenCreateTransactionBody   *message);
size_t proto__token_create_transaction_body__pack
                     (const Proto__TokenCreateTransactionBody   *message,
                      uint8_t             *out);
size_t proto__token_create_transaction_body__pack_to_buffer
                     (const Proto__TokenCreateTransactionBody   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenCreateTransactionBody *
       proto__token_create_transaction_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_create_transaction_body__free_unpacked
                     (Proto__TokenCreateTransactionBody *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__TokenCreateTransactionBody_Closure)
                 (const Proto__TokenCreateTransactionBody *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor proto__token_create_transaction_body__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_TokenCreate_2eproto__INCLUDED */
