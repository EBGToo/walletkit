/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: TokenService.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "TokenService.pb-c.h"
static const ProtobufCMethodDescriptor proto__token_service__method_descriptors[17] =
{
  { "createToken", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "updateToken", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "mintToken", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "burnToken", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "deleteToken", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "wipeTokenAccount", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "freezeTokenAccount", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "unfreezeTokenAccount", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "grantKycToTokenAccount", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "revokeKycFromTokenAccount", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "associateTokens", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "dissociateTokens", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "updateTokenFeeSchedule", &proto__transaction__descriptor, &proto__transaction_response__descriptor },
  { "getTokenInfo", &proto__query__descriptor, &proto__response__descriptor },
  { "getAccountNftInfos", &proto__query__descriptor, &proto__response__descriptor },
  { "getTokenNftInfo", &proto__query__descriptor, &proto__response__descriptor },
  { "getTokenNftInfos", &proto__query__descriptor, &proto__response__descriptor },
};
const unsigned proto__token_service__method_indices_by_name[] = {
  10,        /* associateTokens */
  3,        /* burnToken */
  0,        /* createToken */
  4,        /* deleteToken */
  11,        /* dissociateTokens */
  6,        /* freezeTokenAccount */
  14,        /* getAccountNftInfos */
  13,        /* getTokenInfo */
  15,        /* getTokenNftInfo */
  16,        /* getTokenNftInfos */
  8,        /* grantKycToTokenAccount */
  2,        /* mintToken */
  9,        /* revokeKycFromTokenAccount */
  7,        /* unfreezeTokenAccount */
  1,        /* updateToken */
  12,        /* updateTokenFeeSchedule */
  5         /* wipeTokenAccount */
};
const ProtobufCServiceDescriptor proto__token_service__descriptor =
{
  PROTOBUF_C__SERVICE_DESCRIPTOR_MAGIC,
  "proto.TokenService",
  "TokenService",
  "Proto__TokenService",
  "proto",
  17,
  proto__token_service__method_descriptors,
  proto__token_service__method_indices_by_name
};
void proto__token_service__create_token(ProtobufCService *service,
                                        const Proto__Transaction *input,
                                        Proto__TransactionResponse_Closure closure,
                                        void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 0, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__update_token(ProtobufCService *service,
                                        const Proto__Transaction *input,
                                        Proto__TransactionResponse_Closure closure,
                                        void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 1, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__mint_token(ProtobufCService *service,
                                      const Proto__Transaction *input,
                                      Proto__TransactionResponse_Closure closure,
                                      void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 2, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__burn_token(ProtobufCService *service,
                                      const Proto__Transaction *input,
                                      Proto__TransactionResponse_Closure closure,
                                      void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 3, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__delete_token(ProtobufCService *service,
                                        const Proto__Transaction *input,
                                        Proto__TransactionResponse_Closure closure,
                                        void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 4, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__wipe_token_account(ProtobufCService *service,
                                              const Proto__Transaction *input,
                                              Proto__TransactionResponse_Closure closure,
                                              void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 5, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__freeze_token_account(ProtobufCService *service,
                                                const Proto__Transaction *input,
                                                Proto__TransactionResponse_Closure closure,
                                                void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 6, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__unfreeze_token_account(ProtobufCService *service,
                                                  const Proto__Transaction *input,
                                                  Proto__TransactionResponse_Closure closure,
                                                  void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 7, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__grant_kyc_to_token_account(ProtobufCService *service,
                                                      const Proto__Transaction *input,
                                                      Proto__TransactionResponse_Closure closure,
                                                      void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 8, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__revoke_kyc_from_token_account(ProtobufCService *service,
                                                         const Proto__Transaction *input,
                                                         Proto__TransactionResponse_Closure closure,
                                                         void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 9, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__associate_tokens(ProtobufCService *service,
                                            const Proto__Transaction *input,
                                            Proto__TransactionResponse_Closure closure,
                                            void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 10, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__dissociate_tokens(ProtobufCService *service,
                                             const Proto__Transaction *input,
                                             Proto__TransactionResponse_Closure closure,
                                             void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 11, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__update_token_fee_schedule(ProtobufCService *service,
                                                     const Proto__Transaction *input,
                                                     Proto__TransactionResponse_Closure closure,
                                                     void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 12, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__get_token_info(ProtobufCService *service,
                                          const Proto__Query *input,
                                          Proto__Response_Closure closure,
                                          void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 13, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__get_account_nft_infos(ProtobufCService *service,
                                                 const Proto__Query *input,
                                                 Proto__Response_Closure closure,
                                                 void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 14, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__get_token_nft_info(ProtobufCService *service,
                                              const Proto__Query *input,
                                              Proto__Response_Closure closure,
                                              void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 15, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__get_token_nft_infos(ProtobufCService *service,
                                               const Proto__Query *input,
                                               Proto__Response_Closure closure,
                                               void *closure_data)
{
  assert(service->descriptor == &proto__token_service__descriptor);
  service->invoke(service, 16, (const ProtobufCMessage *) input, (ProtobufCClosure) closure, closure_data);
}
void proto__token_service__init (Proto__TokenService_Service *service,
                                 Proto__TokenService_ServiceDestroy destroy)
{
  protobuf_c_service_generated_init (&service->base,
                                     &proto__token_service__descriptor,
                                     (ProtobufCServiceDestroy) destroy);
}
