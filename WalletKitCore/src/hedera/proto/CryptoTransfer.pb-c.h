/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: CryptoTransfer.proto */

#ifndef PROTOBUF_C_CryptoTransfer_2eproto__INCLUDED
#define PROTOBUF_C_CryptoTransfer_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "BasicTypes.pb-c.h"

typedef struct Proto__CryptoTransferTransactionBody Proto__CryptoTransferTransactionBody;


/* --- enums --- */


/* --- messages --- */

/*
 * Transfers cryptocurrency among two or more accounts by making the desired adjustments to their balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars (there are 100,000,000 tinybars in one hbar).
 *If any sender account fails to have sufficient hbars, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature.
 */
struct  Proto__CryptoTransferTransactionBody
{
  ProtobufCMessage base;
  /*
   * The desired hbar balance adjustments
   */
  Proto__TransferList *transfers;
  /*
   * The desired token unit balance adjustments; if any custom fees are assessed, the ledger will try to deduct them from the payer of this CryptoTransfer, resolving the transaction to INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
   */
  size_t n_tokentransfers;
  Proto__TokenTransferList **tokentransfers;
};
#define PROTO__CRYPTO_TRANSFER_TRANSACTION_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__crypto_transfer_transaction_body__descriptor) \
    , NULL, 0,NULL }


/* Proto__CryptoTransferTransactionBody methods */
void   proto__crypto_transfer_transaction_body__init
                     (Proto__CryptoTransferTransactionBody         *message);
size_t proto__crypto_transfer_transaction_body__get_packed_size
                     (const Proto__CryptoTransferTransactionBody   *message);
size_t proto__crypto_transfer_transaction_body__pack
                     (const Proto__CryptoTransferTransactionBody   *message,
                      uint8_t             *out);
size_t proto__crypto_transfer_transaction_body__pack_to_buffer
                     (const Proto__CryptoTransferTransactionBody   *message,
                      ProtobufCBuffer     *buffer);
Proto__CryptoTransferTransactionBody *
       proto__crypto_transfer_transaction_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__crypto_transfer_transaction_body__free_unpacked
                     (Proto__CryptoTransferTransactionBody *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__CryptoTransferTransactionBody_Closure)
                 (const Proto__CryptoTransferTransactionBody *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor proto__crypto_transfer_transaction_body__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_CryptoTransfer_2eproto__INCLUDED */
